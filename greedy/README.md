# Greedy
### 1. 체육복 (workout_clothes.py)
---
문제 설명

점심시간에 도둑이 들어, 일부 학생이 체육복을 도난당했습니다. 다행히 여벌 체육복이 있는 학생이 이들에게 체육복을 빌려주려 합니다. 학생들의 번호는 체격 순으로 매겨져 있어, 바로 앞번호의 학생이나 바로 뒷번호의 학생에게만 체육복을 빌려줄 수 있습니다. 예를 들어, 4번 학생은 3번 학생이나 5번 학생에게만 체육복을 빌려줄 수 있습니다. 체육복이 없으면 수업을 들을 수 없기 때문에 체육복을 적절히 빌려 최대한 많은 학생이 체육수업을 들어야 합니다.

전체 학생의 수 n, 체육복을 도난당한 학생들의 번호가 담긴 배열 lost, 여벌의 체육복을 가져온 학생들의 번호가 담긴 배열 reserve가 매개변수로 주어질 때, 체육수업을 들을 수 있는 학생의 최댓값을 return 하도록 solution 함수를 작성해주세요.

제한사항
> * 전체 학생의 수는 2명 이상 30명 이하입니다.
> * 체육복을 도난당한 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
> * 여벌의 체육복을 가져온 학생의 수는 1명 이상 n명 이하이고 중복되는 번호는 없습니다.
> * 여벌 체육복이 있는 학생만 다른 학생에게 체육복을 빌려줄 수 있습니다.
> * 여벌 체육복을 가져온 학생이 체육복을 도난당했을 수 있습니다. 이때 이 학생은 체육복을 하나만 도난당했다고 가정하며, 남은 체육복이 하나이기에 다른 학생에게는 체육복을 빌려줄 수 없습니다.


입출력 예

|n|lost|reserve|return|
|:-:|:-:|:----:|:----:|
|5|[2, 4]|[1, 3, 5]|5|
|5|[2, 4]|[3]|4|
|3|[3]|[1]|2|

입출력 예 설명

예제 #1

* 1번 학생이 2번 학생에게 체육복을 빌려주고, 3번 학생이나 5번 학생이 4번 학생에게 체육복을 빌려주면 학생 5명이 체육수업을 들을 수 있습니다.

예제 #2

* 3번 학생이 2번 학생이나 4번 학생에게 체육복을 빌려주면 학생 4명이 체육수업을 들을 수 있습니다.

출처 : https://hsin.hr/coci/archive/2009_2010/contest6_tasks.pdf

문제 접근
> set을 사용하여 lost와 reverse 각각 차집합을 구해준다. 잃어 버린 학생과 여벌이 있는 학생의 번호가 같으면 제외해주기 위해서 이다.

> 여분을 가지고 있는 학생의 번호가 적혀 있는 배열의 앞 부분 부터 꺼내어 잃어 버린 학생의 번호가 적혀 있는 배열 안에 줄 수 있는 학생의 번호가 있는지 확인 후 있다면 주고 배열에서 제거하고 없다면 반복을 다시 진행한다.

> 이 때, 앞 번호 부터 확인한다. 탐욕법의 핵심은 매 순간 최적의 값을 찾아야 한다. 즉, 본 문제와 같은 경우에는 한 방향으로 진행하면서, 해당 분실자가 체육복을 빌릴 수 있는 상황이라면 반드시 빌리고 넘어야야 한다는 소리이다. 그렇지 않을 경우 빌릴 수 있었던 인원이 빌리지 못하게 되는 경우가 발생한다.

> 이를 잃어 버린 학생의 번호가 적혀 있는 배열과 여분을 가지고 있는 학생의 번호가 적혀 있는 배열에 원소가 없을 때까지 반복한다.


### 2. 조이스틱 (joystick.py)
---
문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

> ▲ - 다음 알파벳

> ▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)

> ◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)

> ▶ - 커서를 오른쪽으로 이동

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

> - 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
> - 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
> - 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.
> 따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.

만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

제한사항
> * name은 알파벳 대문자로만 이루어져 있습니다.
> * name의 길이는 1 이상 20 이하입니다.

입출력 예

|name|return|
|:--:|:----:|
|"JEROEN"|56|
|"JAN"|23|

출처 : https://commissies.ch.tudelft.nl/chipcie/archief/2010/nwerc/nwerc2010.pdf

문제 접근
> ASCII 코드를 이용해서 상하로 움직였을 때 더 최소값으로 움직이는 수를 배열에 담는다.

> 또한 좌우로 움직였을 때 최소값으로 움직이는 수를 구해 그만큼 답에 더해준다. index를 통해 현재의 위치를 가르키고 오른쪽과 왼쪽 각각을 계산하여 비교한다. 이 때 만약 왼쪽과 오른쪽의 이동했을 때 최소값이 같다면 오른쪽으로 이동한다.


### 3. 큰 수 만들기 (large_num.py)
---
문제 설명

어떤 숫자에서 k개의 수를 제거했을 때 얻을 수 있는 가장 큰 숫자를 구하려 합니다.

예를 들어, 숫자 1924에서 수 두 개를 제거하면 [19, 12, 14, 92, 94, 24] 를 만들 수 있습니다. 이 중 가장 큰 숫자는 94 입니다.

문자열 형식으로 숫자 number와 제거할 수의 개수 k가 solution 함수의 매개변수로 주어집니다. number에서 k 개의 수를 제거했을 때 만들 수 있는 수 중 가장 큰 숫자를 문자열 형태로 return 하도록 solution 함수를 완성하세요.

제한사항
> * number는 1자리 이상, 1,000,000자리 이하인 숫자입니다.
> * k는 1 이상 number의 자릿수 미만인 자연수입니다.

입출력 예

|number|k|return|
|:----:|:-:|:--:|
|"1924"|2|"94"|
|"1231234"|3|"3234"|
|"4177252841"|4|"775841"|

출처 : https://hsin.hr/coci/archive/2011_2012/contest4_tasks.pdf

문제 접근
> 앞 자리에서부터 하나씩 골라서 담는데, 현재 담으려는 것보다 작은 것들은 도로 뺀다. 이때 뺄 수있는 한계에 도달할 때까지만 뺀다.

> 뺄 수있는 한계를 모두 사용하지 않았으면 뒤에서 부터 한계를 모두 사용할 때까지 빼준다.

### 4. 구명보트 (lifeboat.py)
---
문제 설명

무인도에 갇힌 사람들을 구명보트를 이용하여 구출하려고 합니다. 구명보트는 작아서 한 번에 최대 2명씩 밖에 탈 수 없고, 무게 제한도 있습니다.

예를 들어, 사람들의 몸무게가 [70kg, 50kg, 80kg, 50kg]이고 구명보트의 무게 제한이 100kg이라면 2번째 사람과 4번째 사람은 같이 탈 수 있지만 1번째 사람과 3번째 사람의 무게의 합은 150kg이므로 구명보트의 무게 제한을 초과하여 같이 탈 수 없습니다.

구명보트를 최대한 적게 사용하여 모든 사람을 구출하려고 합니다.

사람들의 몸무게를 담은 배열 people과 구명보트의 무게 제한 limit가 매개변수로 주어질 때, 모든 사람을 구출하기 위해 필요한 구명보트 개수의 최솟값을 return 하도록 solution 함수를 작성해주세요.

제한사항
> * 무인도에 갇힌 사람은 1명 이상 50,000명 이하입니다.
> * 각 사람의 몸무게는 40kg 이상 240kg 이하입니다.
> * 구명보트의 무게 제한은 40kg 이상 240kg 이하입니다.
> * 구명보트의 무게 제한은 항상 사람들의 몸무게 중 최댓값보다 크게 주어지므로 사람들을 구출할 수 없는 경우는 없습니다.

입출력 예

|people|limit|return|
|:----:|:---:|:----:|
|[70, 50, 80, 50]|100|3|
|[70, 80, 50]|100|3|

출처 : https://programmers.co.kr/learn/courses/30/lessons/42885

문제 접근
> 무거운 순서대로 배열을 정렬한다. 제일 무거운 사람과 제일 가벼운 사람을 짝지어 제한 무게를 넘지 않으면 두 사람을 한 보트로 이동 시키고 제한 무게를 넘는다면 무거운 사람만 보트로 이동시킨다. 

> 이 때 제일 무거운 사람과 제일 가벼운 사람을 짝짓는 이유는 제일 무거운 사람과 같이 탈 수 있으면 어차피 그보다 작은 무게의 사람들과도 같이 탈 수 있기 때문에 가장 효율있는 무거운 사람과 먼저 태우는 것이다.

> 이 코드 중 first == last의 부분은 사람이 한 명 남았을 때를 위한 코드이다.


### 5. 섬 연결하기 (connect_island.py) (***)
---
문제 설명

n개의 섬 사이에 다리를 건설하는 비용(costs)이 주어질 때, 최소의 비용으로 모든 섬이 서로 통행 가능하도록 만들 때 필요한 최소 비용을 return 하도록 solution을 완성하세요.

다리를 여러 번 건너더라도, 도달할 수만 있으면 통행 가능하다고 봅니다. 예를 들어 A 섬과 B 섬 사이에 다리가 있고, B 섬과 C 섬 사이에 다리가 있으면 A 섬과 C 섬은 서로 통행 가능합니다.

제한사항
> * 섬의 개수 n은 1 이상 100 이하입니다.
> * costs의 길이는 ((n-1) * n) / 2이하입니다.
> * 임의의 i에 대해, costs[i][0] 와 costs[i] [1]에는 다리가 연결되는 두 섬의 번호가 들어있고, costs[i] [2]에는 이 두 섬을 연결하는 다리를 건설할 때 드는 비용입니다.
> * 같은 연결은 두 번 주어지지 않습니다. 또한 순서가 바뀌더라도 같은 연결로 봅니다. 즉 0과 1 사이를 연결하는 비용이 주어졌을 때, 1과 0의 비용이 주어지지 않습니다.
> * 모든 섬 사이의 다리 건설 비용이 주어지지 않습니다. 이 경우, 두 섬 사이의 건설이 불가능한 것으로 봅니다.
> * 연결할 수 없는 섬은 주어지지 않습니다.

입출력 예

|n|costs|return|
|:-:|:-:|:----:|
|4|[[0,1,1],[0,2,2],[1,2,5],[1,3,1],[2,3,8]]|4|

입출력 예 설명

costs를 그림으로 표현하면 다음과 같으며, 이때 초록색 경로로 연결하는 것이 가장 적은 비용으로 모두를 통행할 수 있도록 만드는 방법입니다.

![image](https://user-images.githubusercontent.com/57613321/128360450-ff67e48d-ab95-4a95-869e-046f2bb97276.png)

출처 : https://programmers.co.kr/learn/courses/30/lessons/42861

문제 접근
> 탐욕적인 방법(greedy method) 을 이용하여 네트워크(가중치를 간선에 할당한 그래프)의 모든 정점을 최소 비용으로 연결하는 최적 해답을 구하는 것을 의미하는 Kruskal 알고리즘을 이용해서 해결할 수 있다.
(https://gmlwjd9405.github.io/2018/08/29/algorithm-kruskal-mst.html)

> 여기서 간략하게 알고리즘을 구현하기 위해서 처음의 점 하나를 set에 넣어주고 점 2개가 모두 들어가 있으면 사이클을 형성하는 것으로 아무 것도 하지 않고 점 한개 만을 포함하고 있으면 경로에 두 점을 포함시켜주고 정답에 cost를 더해준다. 이를 path에 모든 점이 들어올 때까지 반복해준다.

> 이 때 2개 모두 포함하지 않는 경우를 계산해 주지 않은 이유는 지금까지 연결된 점들 중에 연결되는 점이 없기 때문이다.

> 결론적으로, 이 코드는 cost가 제일 적은 한 점으로 부터 cost가 적은 순으로 잇는 것으로 볼 수 있다.
