# DFS/BFS
### 1. 타겟 넘버 (target_num.py)
---
문제 설명

n개의 음이 아닌 정수가 있습니다. 이 수를 적절히 더하거나 빼서 타겟 넘버를 만들려고 합니다. 예를 들어 [1, 1, 1, 1, 1]로 숫자 3을 만들려면 다음 다섯 방법을 쓸 수 있습니다.

> -1+1+1+1+1 = 3
> +1-1+1+1+1 = 3
> +1+1-1+1+1 = 3
> +1+1+1-1+1 = 3
> +1+1+1+1-1 = 3

사용할 수 있는 숫자가 담긴 배열 numbers, 타겟 넘버 target이 매개변수로 주어질 때 숫자를 적절히 더하고 빼서 타겟 넘버를 만드는 방법의 수를 return 하도록 solution 함수를 작성해주세요.

제한사항
> * 주어지는 숫자의 개수는 2개 이상 20개 이하입니다.
> * 각 숫자는 1 이상 50 이하인 자연수입니다.
> * 타겟 넘버는 1 이상 1000 이하인 자연수입니다.

입출력 예

|numbers|target|return|
|:-----:|:----:|:----:|
|[1, 1, 1, 1, 1]|3|5|

입출력 예 설명

문제에 나온 예와 같습니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/43165

문제 접근
> 한 단계 아래로 내려갈때마다 각 경우의 덧셈 뺄셈을 다 해보고, 최종 결과를 내는 것으로 접근했다.

> deque를 통해 합과 index가 포함되어 있는 튜플을 저장하고 bfs로 문제를 해결했다.

> pop한 index가 마지막 index이고 값이 target과 같다면 answer += 1을 해준다.

> pop한 indexx가 number의 개수를 초과하면 반복을 멈춘다.


### 2. 네트워크 (network.py)
---
문제 설명

네트워크란 컴퓨터 상호 간에 정보를 교환할 수 있도록 연결된 형태를 의미합니다. 예를 들어, 컴퓨터 A와 컴퓨터 B가 직접적으로 연결되어있고, 컴퓨터 B와 컴퓨터 C가 직접적으로 연결되어 있을 때 컴퓨터 A와 컴퓨터 C도 간접적으로 연결되어 정보를 교환할 수 있습니다. 따라서 컴퓨터 A, B, C는 모두 같은 네트워크 상에 있다고 할 수 있습니다.

컴퓨터의 개수 n, 연결에 대한 정보가 담긴 2차원 배열 computers가 매개변수로 주어질 때, 네트워크의 개수를 return 하도록 solution 함수를 작성하시오.

제한사항
> * 컴퓨터의 개수 n은 1 이상 200 이하인 자연수입니다.
> * 각 컴퓨터는 0부터 n-1인 정수로 표현합니다.
> * i번 컴퓨터와 j번 컴퓨터가 연결되어 있으면 computers[i][j]를 1로 표현합니다.
> * computer[i][i]는 항상 1입니다.

입출력 예

|n|computers|return|
|:-:|:-----:|:----:|
|3|[[1, 1, 0], [1, 1, 0], [0, 0, 1]]|2|
|3|[[1, 1, 0], [1, 1, 1], [0, 1, 1]]|1|

입출력 예 설명

예제 #1

아래와 같이 2개의 네트워크가 있습니다.

![image](https://user-images.githubusercontent.com/57613321/129688070-bfda3655-5ef4-4b5d-867a-bdf6ca5f63dc.png)

예제 #2

아래와 같이 1개의 네트워크가 있습니다.

![image](https://user-images.githubusercontent.com/57613321/129688088-53b1bfb6-5556-4d72-847b-cc4491f9c9b1.png)

출처 : https://programmers.co.kr/learn/courses/30/lessons/43162

문제 접근
> DFS, BFS은 특징에 따라 사용에 더 적합한 문제 유형들이 있습니다.

> 1) 그래프의 모든 정점을 방문하는 것이 주요한 문제
> * 단순히 모든 정점을 방문하는 것이 중요한 문제의 경우 DFS, BFS 두 가지 방법 중 어느 것을 사용하셔도 상관없습니다.
둘 중 편한 것을 사용하시면 됩니다.

> 2) 경로의 특징을 저장해둬야 하는 문제
> * 예를 들면 각 정점에 숫자가 적혀있고 a부터 b까지 가는 경로를 구하는데 경로에 같은 숫자가 있으면 안 된다는 문제 등, 각각의 경로마다 특징을 저장해둬야 할 때는 DFS를 사용합니다. (BFS는 경로의 특징을 가지지 못합니다)

> 3) 최단거리 구해야 하는 문제
> * 미로 찾기 등 최단거리를 구해야 할 경우, BFS가 유리합니다.
> * 왜냐하면 깊이 우선 탐색으로 경로를 검색할 경우 처음으로 발견되는 해답이 최단거리가 아닐 수 있지만, 
너비 우선 탐색으로 현재 노드에서 가까운 곳부터 찾기 때문에경로를 탐색 시 먼저 찾아지는 해답이 곧 최단거리기 때문입니다.

> 이밖에도 
> - 검색 대상 그래프가 정말 크다면 DFS를 고려
> - 검색대상의 규모가 크지 않고, 검색 시작 지점으로부터 원하는 대상이 별로 멀지 않다면 BFS

> 출처: https://devuna.tistory.com/32 [튜나 개발일기]

> 해당노드를 방문했는지 확인하는 check 배열을 만든다.

> 첫 노드 부터 연결지점을 DFS를 통해 탐색한다. (연결되어 있지만 방문하지 않은 노드를 재귀를 통해 탐색)


### 3. 단어 변환 (word_conversion.py)
---
문제 설명

두 개의 단어 begin, target과 단어의 집합 words가 있습니다. 아래와 같은 규칙을 이용하여 begin에서 target으로 변환하는 가장 짧은 변환 과정을 찾으려고 합니다.

> 1. 한 번에 한 개의 알파벳만 바꿀 수 있습니다.
> 2. words에 있는 단어로만 변환할 수 있습니다.

예를 들어 begin이 "hit", target가 "cog", words가 ["hot","dot","dog","lot","log","cog"]라면 "hit" -> "hot" -> "dot" -> "dog" -> "cog"와 같이 4단계를 거쳐 변환할 수 있습니다.

두 개의 단어 begin, target과 단어의 집합 words가 매개변수로 주어질 때, 최소 몇 단계의 과정을 거쳐 begin을 target으로 변환할 수 있는지 return 하도록 solution 함수를 작성해주세요.

제한사항
> * 각 단어는 알파벳 소문자로만 이루어져 있습니다.
> * 각 단어의 길이는 3 이상 10 이하이며 모든 단어의 길이는 같습니다.
> * words에는 3개 이상 50개 이하의 단어가 있으며 중복되는 단어는 없습니다.
> * begin과 target은 같지 않습니다.
> * 변환할 수 없는 경우에는 0를 return 합니다.

입출력 예

|begin|target|words|return|
|:---:|:----:|:---:|:----:|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log", "cog"]|4|
|"hit"|"cog"|["hot", "dot", "dog", "lot", "log"]|0|

입출력 예 설명

예제 #1

문제에 나온 예와 같습니다.

예제 #2

target인 "cog"는 words 안에 없기 때문에 변환할 수 없습니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/43163

문제 접근
> 첫 문장을 배열에 집어넣고 하나씩 꺼내며 차례대로 BFS를 통해 탐색한다. 탐색하다 target과 같은 단어가 완성되면 반복을 멈추고 탐색된 단어의 index를 출력한다.

> [c1 == c2 for c1, c2 in zip(compar, i)].count(False) == 1 는 문자열 중 다른 문자가 1개 있는 것을 찾기위한 코드이다.


### 4. 여행 경로 (travel_route.py) ***
---
문제 설명

주어진 항공권을 모두 이용하여 여행경로를 짜려고 합니다. 항상 "ICN" 공항에서 출발합니다.

항공권 정보가 담긴 2차원 배열 tickets가 매개변수로 주어질 때, 방문하는 공항 경로를 배열에 담아 return 하도록 solution 함수를 작성해주세요.

제한사항
> * 모든 공항은 알파벳 대문자 3글자로 이루어집니다.
> * 주어진 공항 수는 3개 이상 10,000개 이하입니다.
> * tickets의 각 행 [a, b]는 a 공항에서 b 공항으로 가는 항공권이 있다는 의미입니다.
> * 주어진 항공권은 모두 사용해야 합니다.
> * 만일 가능한 경로가 2개 이상일 경우 알파벳 순서가 앞서는 경로를 return 합니다.
> * 모든 도시를 방문할 수 없는 경우는 주어지지 않습니다.

입출력 예

|tickets|return|
|:-----:|:----:|
|[["ICN", "JFK"], ["HND", "IAD"], ["JFK", "HND"]]|["ICN", "JFK", "HND", "IAD"]|
|[["ICN", "SFO"], ["ICN", "ATL"], ["SFO", "ATL"], ["ATL", "ICN"], ["ATL","SFO"]]|["ICN", "ATL", "ICN", "SFO", "ATL", "SFO"]|

입출력 예 설명

예제 #1

["ICN", "JFK", "HND", "IAD"] 순으로 방문할 수 있습니다.

예제 #2

["ICN", "SFO", "ATL", "ICN", "ATL", "SFO"] 순으로 방문할 수도 있지만 ["ICN", "ATL", "ICN", "SFO", "ATL", "SFO"] 가 알파벳 순으로 앞섭니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/43164

문제 접근
> 처음에 알파벳 순으로 해서 경로 하나만을 탐색했는데 모든 지역을 다 돌지않는 경우가 생겼다. 따라서 경로를 모두 탐색 못할 경우에는 다시 돌아가서 경로를 계산해야 했다.

> DFS 문제임을 알았음에도 풀지 못했다. 방문 여부 확인하는 것을 true, false로만 생각하지 말고 리스트에 저장하는 방식도 생각해야겠다 또한 stack을 통한 DFS 풀이 이외에도 재귀를 통한 DFS 풀이도 신경써서 학습해야겠다.

> https://lionem2018.tistory.com/entry/ProgrammersLevel-3Python-%EC%97%AC%ED%96%89%EA%B2%BD%EB%A1%9C 를 통해 문제 해결 방법에 대해서 알 수 있었다.
