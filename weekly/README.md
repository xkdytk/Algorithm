# Weekly Challenge
---
## 1주차
### 1. 부족한 금액 계산하기 (insufficient_amount.py)
---
문제 설명

새로 생긴 놀이기구는 인기가 매우 많아 줄이 끊이질 않습니다. 이 놀이기구의 원래 이용료는 price원 인데, 놀이기구를 N 번 째 이용한다면 원래 이용료의 N배를 받기로 하였습니다. 즉, 처음 이용료가 100이었다면 2번째에는 200, 3번째에는 300으로 요금이 인상됩니다.
놀이기구를 count번 타게 되면 현재 자신이 가지고 있는 금액에서 얼마가 모자라는지를 return 하도록 solution 함수를 완성하세요.
단, 금액이 부족하지 않으면 0을 return 하세요.

제한사항
> * 놀이기구의 이용료 price : 1 ≤ price ≤ 2,500, price는 자연수
> * 처음 가지고 있던 금액 money : 1 ≤ money ≤ 1,000,000,000, money는 자연수
> * 놀이기구의 이용 횟수 count : 1 ≤ count ≤ 2,500, count는 자연수


입출력 예

|price|money|count|result|
|:---:|:---:|:---:|:----:|
|3|20|4|10|

입출력 예 설명

입출력 예 #1

* 이용금액이 3인 놀이기구를 4번 타고 싶은 고객이 현재 가진 금액이 20이라면, 총 필요한 놀이기구의 이용 금액은 30 (= 3+6+9+12) 이 되어 10만큼 부족하므로 10을 return 합니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/82612

문제 접근
> 등차 수열의 합 공식을 통해 해결한다.


## 2주차
### 2. 상호 평가 (mutual_evaluation.py)
---
문제 설명

대학 교수인 당신은, 상호평가를 통하여 학생들이 제출한 과제물에 학점을 부여하려고 합니다. 아래는 0번부터 4번까지 번호가 매겨진 5명의 학생들이 자신과 다른 학생의 과제를 평가한 점수표입니다.

|No.|0|1|2|3|4|
|:-:|:-:|:-:|:-:|:-:|:-:|
|0|100|90|98|88|65|
|1|50|45|99|85|77|
|2|47|88|95|80|67|
|3|61|57|100|80|65|
|4|24|90|94|75|65|
|평균|45.5|81.25|97.2|81.6|67.8|
|학점|F|B|A|B|D|

위의 점수표에서, i행 j열의 값은 i번 학생이 평가한 j번 학생의 과제 점수입니다.

> * 0번 학생이 평가한 점수는 0번 행에담긴 [100, 90, 98, 88, 65]입니다.
>   * 0번 학생은 자기 자신에게 100점, 1번 학생에게 90점, 2번 학생에게 98점, 3번 학생에게 88점, 4번 학생에게 65점을 부여했습니다.
> * 2번 학생이 평가한 점수는 2번 행에담긴 [47, 88, 95, 80, 67]입니다.
>   * 2번 학생은 0번 학생에게 47점, 1번 학생에게 88점, 자기 자신에게 95점, 3번 학생에게 80점, 4번 학생에게 67점을 부여했습니다.

당신은 각 학생들이 받은 점수의 평균을 구하여, 기준에 따라 학점을 부여하려고 합니다.

만약, 학생들이 자기 자신을 평가한 점수가 유일한 최고점 또는 유일한 최저점이라면 그 점수는 제외하고 평균을 구합니다.

> * 0번 학생이 받은 점수는 0번 열에 담긴 [100, 50, 47, 61, 24]입니다. 자기 자신을 평가한 100점은 자신이 받은 점수 중에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.
>   * 0번 학생의 평균 점수는 (50+47+61+24) / 4 = 45.5입니다.
> * 4번 학생이 받은 점수는 4번 열에 담긴 [65, 77, 67, 65, 65]입니다. 자기 자신을 평가한 65점은 자신이 받은 점수 중에서 최저점이지만 같은 점수가 2개 더 있으므로, 유일한 최저점이 아닙니다. 따라서, 평균을 구할 때 제외하지 않습니다.
>   * 4번 학생의 평균 점수는 (65+77+67+65+65) / 5 = 67.8입니다.

제외할 점수는 제외하고 평균을 구한 후, 아래 기준에 따라 학점을 부여합니다.

|평균|학점|
|:-:|:-:|
|90점 이상|A|
|80점 이상 90점 미만|B|
|70점 이상 80점 미만|C|
|50점 이상 70점 미만|D|
|50점 미만|F|

학생들의 점수가 담긴 정수형 2차원 배열 scores가 매개변수로 주어집니다. 이때, 학생들의 학점을 구하여 하나의 문자열로 만들어서 return 하도록 solution 함수를 완성해주세요.

제한사항
> * 2 ≤ scores의 행의 길이(학생 수) ≤ 10
> * scores의 열의 길이 = scores의 행의 길이
>   * 즉, scores는 행과 열의 길이가 같은 2차원 배열입니다.
> * 0 ≤ scores의 원소 ≤ 100
> * return 값 형식
>   * 0번 학생의 학점부터 차례대로 이어 붙인 하나의 문자열을 return 합니다.


입출력 예

|scores|result|
|:----:|:----:|
|[[100,90,98,88,65],[50,45,99,85,77],[47,88,95,80,67],[61,57,100,80,65],[24,90,94,75,65]]|"FBABD"|
|[[50,90],[50,87]]|"DA"|
|[[70,49,90],[68,50,38],[73,31,100]]|"CFD"|

입출력 예 설명

입출력 예 #1

문제 예시와 같습니다.

입출력 예 #2

|No.|0|1|
|:-:|:-:|:-:|
|0|50|90|
|1|50|87|
|평균|50|90|
|학점|D|A|

* 1번 학생이 자기 자신을 평가한 87점은 [90, 87]에서 유일한 최저점이므로, 평균을 구할 때 제외합니다.

입출력 예 #3

|No.|0|1|2|
|:-:|:-:|:-:|:-:|
|0|70|49|90|
|1|68|50|38|
|2|73|31|100|
|평균|70.33…|40|64|
|학점|C|F|D|

* 1번 학생이 자기 자신을 평가한 50점은 [49, 50, 31]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.
* 2번 학생이 자기 자신을 평가한 100점은 [90, 38, 100]에서 유일한 최고점이므로, 평균을 구할 때 제외합니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/83201

문제 접근
> numpy를 통해 행렬 문제를 간단하게 계산한다.

> scores[:,i]를 통해서 열 부분을 추출할 수 있다.

> numpy.count_nonzero(a, axis=None, *, keepdims=False) 를 통해서 배열 a 의 0이 아닌 값의 개수를 계산할 수 있다. 이 점을 이용해서 np.count_nonzero(score == np.max(score)) == 1를 사용해서 최대값이 유일값인지 확인한다.

> np.delete(score, np.argmax(score))를 통해서 최대값의 index를 찾아서 그 요소를 제거한다.


## 4주차
### 4. 직업군 추천하기 (occupational_group.py)
---
문제 설명

개발자가 사용하는 언어와 언어 선호도를 입력하면 그에 맞는 직업군을 추천해주는 알고리즘을 개발하려고 합니다.

아래 표는 5개 직업군 별로 많이 사용하는 5개 언어에 직업군 언어 점수를 부여한 표입니다.

|점수|SI|CONTENTS|HARDWARE|PORTAL|GAME|
|:-:|:-:|:-----:|:------:|:----:|:--:|
|5|JAVA|JAVASCRIPT|C|JAVA|C++|
|4|JAVASCRIPT|JAVA|C++|JAVASCRIPT|C#|
|3|SQL|PYTHON|PYTHON|PYTHON|JAVASCRIPT|
|2|PYTHON|SQL|JAVA|KOTLIN|C|
|1|C#|C++|JAVASCRIPT|PHP|JAVA|

예를 들면, SQL의 SI 직업군 언어 점수는 3점이지만 CONTENTS 직업군 언어 점수는 2점입니다. SQL의 HARDWARE, PORTAL, GAME 직업군 언어 점수는 0점입니다.

직업군 언어 점수를 정리한 문자열 배열 table, 개발자가 사용하는 언어를 담은 문자열 배열 languages, 언어 선호도를 담은 정수 배열 preference가 매개변수로 주어집니다. 개발자가 사용하는 언어의 언어 선호도 x 직업군 언어 점수의 총합이 가장 높은 직업군을 return 하도록 solution 함수를 완성해주세요. 총합이 같은 직업군이 여러 개일 경우, 이름이 사전 순으로 가장 빠른 직업군을 return 해주세요.

제한사항
> * table의 길이 = 5
>   * table의 원소는 "직업군 5점언어 4점언어 3점언어 2점언어 1점언어"형식의 문자열입니다. 직업군, 5점언어, 4언어, 3점언어, 2점언어, 1점언어는 하나의 공백으로 구분되어 있습니다.
>   * table은 모든 테스트케이스에서 동일합니다.
> * 1 ≤ languages의 길이 ≤ 9
>   * languages의 원소는 "JAVA", "JAVASCRIPT", "C", "C++" ,"C#" , "SQL", "PYTHON", "KOTLIN", "PHP" 중 한 개 이상으로 이루어져 있습니다.
>   * languages의 원소는 중복되지 않습니다.
> * preference의 길이 = languages의 길이
>   * 1 ≤ preference의 원소 ≤ 10
> * preference의 i번째 원소는 languages의 i번째 원소의 언어 선호도입니다.
> * return 할 문자열은 "SI", "CONTENTS", "HARDWARE", "PORTAL", "GAME" 중 하나입니다.

입출력 예

|table|languages|preference|result|
|:---:|:-------:|:--------:|:----:|
|["SI JAVA JAVASCRIPT SQL PYTHON C#", "CONTENTS JAVASCRIPT JAVA PYTHON SQL C++", "HARDWARE C C++ PYTHON JAVA JAVASCRIPT", "PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP", "GAME C++ C# JAVASCRIPT C JAVA"]|["PYTHON", "C++", "SQL"]|[7, 5, 5]|"HARDWARE"|
|["SI JAVA JAVASCRIPT SQL PYTHON C#", "CONTENTS JAVASCRIPT JAVA PYTHON SQL C++", "HARDWARE C C++ PYTHON JAVA JAVASCRIPT", "PORTAL JAVA JAVASCRIPT PYTHON KOTLIN PHP", "GAME C++ C# JAVASCRIPT C JAVA"]|["JAVA", "JAVASCRIPT"]|[7, 5]|"PORTAL"|

입출력 예 설명

입출력 예 #1

각 직업군 별로 점수를 계산해보면 아래와 같습니다.

아래 사진은 개발자 언어 선호도 나타낸 표입니다.

![image](https://user-images.githubusercontent.com/57613321/130587572-1f4b78c3-bb80-40a2-a631-5c2a86af44ff.png)

아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.

![image](https://user-images.githubusercontent.com/57613321/130587600-dba48c2b-f76e-4a9a-ab4f-ae2199abcfd2.png)

따라서 점수 총합이 41로 가장 높은 "HARDWARE"를 return 해야 합니다.

입출력 예 #2

각 직업군 별로 점수를 계산해보면 아래와 같습니다.

아래 사진은 개발자 언어 선호도 나타낸 표입니다.

![image](https://user-images.githubusercontent.com/57613321/130587631-0cb2e472-4b86-45d1-9294-5ebad6e2f12e.png)

아래 사진은 개발자가 선호하는 언어의 직업군 언어 점수를 나타낸 표입니다.

![image](https://user-images.githubusercontent.com/57613321/130587648-c4548ed7-dd33-454f-a020-63d1ca8c97a7.png)

점수 총합이 55로 가장 높은 직업군은 "SI" 와 "PORTAL"입니다.

따라서 사전 순으로 먼저 오는 "PORTAL"을 return 해야 합니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/84325

문제 접근
> 반복문을 통해 반복하면서 언어선호도 * 직업군 언어 점수를 계산해서 계산결과를 각 직업군을 의미하는 dictionary에 추가했다.

> 마지막으로 직업군을 의미하는 dictionary를 값에 대해 먼저 역정렬하고, 키에 대해 정렬하여 첫 번째 요소를 정답으로 출력했다.

> 1. 정렬을 여러 개의 조건으로 하는 방법
> * 비교할 아이템의 요소가 복수 개일 경우, 튜플로 그 순서를 내보내주면 된다.
>   * ex. sorted(e, key = lambda x : (x[0], -x[1]))
>   * -를 붙이면, 현재 정렬차순과 반대로 하게 된다.


## 5주차
### 5. 모음 사전 (vowel_dictionary.py)
---
문제 설명

사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA"이며, 마지막 단어는 "UUUUU"입니다.

단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.

제한사항
> * word의 길이는 1 이상 5 이하입니다.
> * word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다.

입출력 예

|word|result|
|:--:|:----:|
|"AAAAE"|6|
|"AAAE"|10|
|"I"|1563|
|"EIO"|1189|

입출력 예 설명

입출력 예 #1

사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA", "AAA", "AAAA", "AAAAA", "AAAAE", ... 와 같습니다. "AAAAE"는 사전에서 6번째 단어입니다.

입출력 예 #2

"AAAE"는 "A", "AA", "AAA", "AAAA", "AAAAA", "AAAAE", "AAAAI", "AAAAO", "AAAAU"의 다음인 10번째 단어입니다.

입출력 예 #3

"I"는 1563번째 단어입니다.

입출력 예 #4

"EIO"는 1189번째 단어입니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/84512

문제 접근
> 각 자리가 비어 있기 까지의 경우의 수는 문자 5개를 반복한 후 비어있는 경우를 더한 값이 된다. 즉, 마지막 한자리 수가 비워져 있을 경우의 수는 5+1이다. 

> 여기서 비어져 있는 문자 직전의 자리의 문자에 따라서 경우의 수가 달라진다. 예를 들어 마지막 한자리 수가 비워져 있는 상태에서 그 앞자리가 "A"라면 뒤의 자리가 비워진 것이 아니기 때문에 0을 곱하고, "I"라면 뒤의 자리가 두 번 비워진 것(앞의 자리가 "A", "E"일 때)이기 때문에 2를 곱한다.

> 위의 값들을 더하는 것은 빈 자리에 대한 것이므로 그 값에 1을 더해줘서 내가 원하는 자리를 만들어 준다. 이를 각 자리마다 반복하여 값을 구한다.


## 6주차
### 6. 복서 정렬하기 (boxer_sorting.py)
---
문제 설명

복서 선수들의 몸무게 weights와, 복서 선수들의 전적을 나타내는 head2head가 매개변수로 주어집니다. 복서 선수들의 번호를 다음과 같은 순서로 정렬한 후 return 하도록 solution 함수를 완성해주세요.

1. 전체 승률이 높은 복서의 번호가 앞쪽으로 갑니다. 아직 다른 복서랑 붙어본 적이 없는 복서의 승률은 0%로 취급합니다.
2. 승률이 동일한 복서의 번호들 중에서는 자신보다 몸무게가 무거운 복서를 이긴 횟수가 많은 복서의 번호가 앞쪽으로 갑니다.
3. 자신보다 무거운 복서를 이긴 횟수까지 동일한 복서의 번호들 중에서는 자기 몸무게가 무거운 복서의 번호가 앞쪽으로 갑니다.
4. 자기 몸무게까지 동일한 복서의 번호들 중에서는 작은 번호가 앞쪽으로 갑니다.


제한사항
> * weights의 길이는 2 이상 1,000 이하입니다.
>   * weights의 모든 값은 45 이상 150 이하의 정수입니다.
>   * weights[i] 는 i+1번 복서의 몸무게(kg)를 의미합니다.
> * head2head의 길이는 weights의 길이와 같습니다.
>   * head2head의 모든 문자열은 길이가 weights의 길이와 동일하며, 'N', 'W', 'L'로 이루어진 문자열입니다.
>   * head2head[i] 는 i+1번 복서의 전적을 의미하며, head2head[i][j]는 i+1번 복서와 j+1번 복서의 매치 결과를 의미합니다.
>       * 'N' (None)은 두 복서가 아직 붙어본 적이 없음을 의미합니다.
>       * 'W' (Win)는 i+1번 복서가 j+1번 복서를 이겼음을 의미합니다.
>       * 'L' (Lose)는 i+1번 복사가 j+1번 복서에게 졌음을 의미합니다.
>   * 임의의 i에 대해서 head2head[i][i] 는 항상 'N'입니다. 자기 자신과 싸울 수는 없기 때문입니다.
>   * 임의의 i, j에 대해서 head2head[i][j] = 'W' 이면, head2head[j][i] = 'L'입니다.
>   * 임의의 i, j에 대해서 head2head[i][j] = 'L' 이면, head2head[j][i] = 'W'입니다.
>   * 임의의 i, j에 대해서 head2head[i][j] = 'N' 이면, head2head[j][i] = 'N'입니다.

입출력 예

|weights|head2head|result|
|:-----:|:-------:|:----:|
|[50,82,75,120]|["NLWL","WNLL","LWNW","WWLN"]|[3,4,1,2]|
|[145,92,86]|["NLW","WNL","LWN"]|[2,3,1]|
|[60,70,60]|["NNN","NNN","NNN"]|[2,1,3]|

입출력 예 설명

입출력 예 #1

* 다음은 선수들의 정보를 나타낸 표입니다.

|선수 번호|vs 1번|vs 2번|vs 3번|vs 4번|승률|자기보다 무거운 복서를 이긴 횟수|몸무게|
|:-----:|:---:|:---:|:----:|:---:|:-:|:----------------------:|:---:|
|1번|-|패배|승리|패배|33.33%|1회|50kg|
|2번|승리|-|패배|패배|33.33%|0회|82kg|
|3번|패배|승리|-|승리|66.66%|2회|75kg|
|4번|승리|승리|패배|-|66.66%|0회|120kg|

* 본문에 서술된 우선순위를 따라 [3,4,1,2] 를 return 합니다.

입출력 예 #2

* 다음은 선수들의 정보를 나타낸 표입니다.

|선수 번호|vs 1번|vs 2번|vs 3번|승률|자기보다 무거운 복서를 이긴 횟수|몸무게|
|:-----:|:---:|:---:|:----:|:-:|:----------------------:|:---:|
|1번|-|패배|승리|50%|0회|145kg|
|2번|승리|-|패배|50%|1회|92kg|
|3번|패배|승리|-|50%|1회|86kg|

* 본문에 서술된 우선순위를 따라 [2,3,1] 을 return 합니다.

입출력 예 #3

* 다음은 선수들의 정보를 나타낸 표입니다.

|선수 번호|vs 1번|vs 2번|vs 3번|승률|자기보다 무거운 복서를 이긴 횟수|몸무게|
|:-----:|:---:|:---:|:----:|:-:|:----------------------:|:---:|
|1번|-|-|-|0% (무전적)|0회|60kg|
|2번|-|-|-|0% (무전적)|0회|70kg|
|3번|-|-|-|0% (무전적)|0회|60kg|

* 본문에 서술된 우선순위를 따라 [2,1,3] 을 return 합니다.

출처 : https://programmers.co.kr/learn/courses/30/lessons/85002

문제 접근
> 각 선수들의 정보(key=선수번호, value=[승률, 본인보다 무거운 선수를 이긴 횟수, 해당 선수의 몸무게])를 저장할 딕셔너리를 선언하여 각 위치마다 요소를 추가해준다.

> 우선순위 순으로 정렬을 하고 선수번호를 answer에 저장한다.